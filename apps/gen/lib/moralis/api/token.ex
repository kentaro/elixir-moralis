# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# https://openapi-generator.tech
# Do not edit the class manually.

defmodule Moralis.Api.Token do
  @moduledoc """
  API calls for all endpoints tagged `Token`.
  """

  alias Moralis.Connection
  import Moralis.RequestBuilder


  @doc """
  Retrieves the unique NFTs inside a given contract
  Gets data, including metadata (where available), for all token ids for the given contract address. * Results are sorted by the block the token id was minted (descending) and limited to 100 per page by default * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :offset (integer()): offset
    - :limit (integer()): limit
    - :cursor (String.t): The cursor returned in the last response (for getting the next page) 
  ## Returns

  {:ok, Moralis.Model.NftCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_all_token_ids(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.NftCollection.t} | {:error, Tesla.Env.t}
  def get_all_token_ids(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"offset" => :query,
      :"limit" => :query,
      :"cursor" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftCollection{}}
    ])
  end

  @doc """
  Gets NFT transfers of a given contract
  Gets the transfers of the tokens matching the given parameters

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :offset (integer()): offset
    - :limit (integer()): limit
    - :cursor (String.t): The cursor returned in the last response (for getting the next page) 
  ## Returns

  {:ok, Moralis.Model.NftTransferCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_contract_nft_transfers(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.NftTransferCollection.t} | {:error, Tesla.Env.t}
  def get_contract_nft_transfers(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"offset" => :query,
      :"limit" => :query,
      :"cursor" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/transfers")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftTransferCollection{}}
    ])
  end

  @doc """
  Get the lowest price found for a nft token contract
  Get the lowest price found for a nft token contract for the last x days (only trades paid in ETH)

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :days (integer()): The number of days to look back to find the lowest price If not provided 7 days will be the default 
    - :provider_url (String.t): web3 provider url to user when using local dev chain
    - :marketplace (String.t): marketplace from where to get the trades (only opensea is supported at the moment)
  ## Returns

  {:ok, Moralis.Model.Trade.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_nft_lowest_price(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.Trade.t} | {:error, Tesla.Env.t}
  def get_nft_lowest_price(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"days" => :query,
      :"provider_url" => :query,
      :"marketplace" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/lowestprice")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.Trade{}}
    ])
  end

  @doc """
  Gets the global metadata for a given contract
  Gets the contract level metadata (name, symbol, base token uri) for the given contract * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
  ## Returns

  {:ok, Moralis.Model.NftContractMetadata.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_nft_metadata(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.NftContractMetadata.t} | {:error, Tesla.Env.t}
  def get_nft_metadata(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/metadata")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftContractMetadata{}}
    ])
  end

  @doc """
  Gets the owners of the NFTs of a given contract
  Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :offset (integer()): offset
    - :limit (integer()): limit
    - :cursor (String.t): The cursor returned in the last response (for getting the next page) 
  ## Returns

  {:ok, Moralis.Model.NftOwnerCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_nft_owners(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.NftOwnerCollection.t} | {:error, Tesla.Env.t}
  def get_nft_owners(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"offset" => :query,
      :"limit" => :query,
      :"cursor" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/owners")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftOwnerCollection{}}
    ])
  end

  @doc """
  Get nft trades by marketplaces
  Get the nft trades for a given contracts and marketplace

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :from_block (integer()): The minimum block number from where to get the transfers * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_block (String.t): To get the reserves at this block number
    - :from_date (String.t): The date from where to get the transfers (any format that is accepted by momentjs) * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_date (String.t): Get the reserves to this date (any format that is accepted by momentjs) * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :provider_url (String.t): web3 provider url to user when using local dev chain
    - :marketplace (String.t): marketplace from where to get the trades (only opensea is supported at the moment)
    - :offset (integer()): offset
    - :limit (integer()): limit
  ## Returns

  {:ok, Moralis.Model.TradeCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_nft_trades(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.TradeCollection.t} | {:error, Tesla.Env.t}
  def get_nft_trades(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"from_block" => :query,
      :"to_block" => :query,
      :"from_date" => :query,
      :"to_date" => :query,
      :"provider_url" => :query,
      :"marketplace" => :query,
      :"offset" => :query,
      :"limit" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/trades")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.TradeCollection{}}
    ])
  end

  @doc """
  Gets NFT transfers from a block number to a block number
  Gets the transfers of the tokens from a block number to a block number

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :from_block (integer()): The minimum block number from where to get the transfers * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_block (integer()): The maximum block number from where to get the transfers. * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :from_date (String.t): The date from where to get the transfers (any format that is accepted by momentjs) * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_date (String.t): Get transfers up until this date (any format that is accepted by momentjs) * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :format (String.t): The format of the token id
    - :offset (integer()): offset
    - :limit (integer()): limit
    - :cursor (String.t): The cursor returned in the last response (for getting the next page) 
  ## Returns

  {:ok, Moralis.Model.NftTransferCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_nft_transfers_from_to_block(Tesla.Env.client, keyword()) :: {:ok, Moralis.Model.NftTransferCollection.t} | {:error, Tesla.Env.t}
  def get_nft_transfers_from_to_block(connection, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"from_block" => :query,
      :"to_block" => :query,
      :"from_date" => :query,
      :"to_date" => :query,
      :"format" => :query,
      :"offset" => :query,
      :"limit" => :query,
      :"cursor" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/transfers")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftTransferCollection{}}
    ])
  end

  @doc """
  Gets erc20 transactions of a token contract
  Gets ERC20 token contract transactions in descending order based on block number

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): The address of the token contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :subdomain (String.t): The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
    - :from_block (integer()): The minimum block number from where to get the transfers * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_block (integer()): The maximum block number from where to get the transfers. * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :from_date (String.t): The date from where to get the transfers (any format that is accepted by momentjs) * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_date (String.t): Get the transfers to this date (any format that is accepted by momentjs) * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :offset (integer()): offset
    - :limit (integer()): limit
  ## Returns

  {:ok, Moralis.Model.Erc20TransactionCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_address_transfers(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.Erc20TransactionCollection.t} | {:error, Tesla.Env.t}
  def get_token_address_transfers(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"subdomain" => :query,
      :"from_block" => :query,
      :"to_block" => :query,
      :"from_date" => :query,
      :"to_date" => :query,
      :"offset" => :query,
      :"limit" => :query
    }
    %{}
    |> method(:get)
    |> url("/erc20/#{address}/transfers")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.Erc20TransactionCollection{}}
    ])
  end

  @doc """
  Gets the amount which the spender is allowed to withdraw from the owner.
  Gets the amount which the spender is allowed to withdraw from the spender

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): The address of the token contract
  - owner_address (String.t): The address of the token owner
  - spender_address (String.t): The address of the token spender
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :provider_url (String.t): web3 provider url to user when using local dev chain
  ## Returns

  {:ok, Moralis.Model.Erc20Allowance.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_allowance(Tesla.Env.client, String.t, String.t, String.t, keyword()) :: {:ok, Moralis.Model.Erc20Allowance.t} | {:error, Tesla.Env.t}
  def get_token_allowance(connection, address, owner_address, spender_address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"providerUrl" => :query
    }
    %{}
    |> method(:get)
    |> url("/erc20/#{address}/allowance")
    |> add_param(:query, :"owner_address", owner_address)
    |> add_param(:query, :"spender_address", spender_address)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.Erc20Allowance{}}
    ])
  end

  @doc """
  Gets the NFT with the given id of a given contract
  Gets data, including metadata (where available), for the given token id of the given contract address. * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - token_id (String.t): The id of the token
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
  ## Returns

  {:ok, Moralis.Model.Nft.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_id_metadata(Tesla.Env.client, String.t, String.t, keyword()) :: {:ok, Moralis.Model.Nft.t} | {:error, Tesla.Env.t}
  def get_token_id_metadata(connection, address, token_id, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/#{token_id}")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.Nft{}}
    ])
  end

  @doc """
  Gets the owners of NFTs for a given contract
  Gets all owners of NFT items within a given contract collection * Use after /nft/contract/{token_address} to find out who owns each token id in a collection * Make sure to include a sort parm on a column like block_number_minted for consistent pagination results * Requests for contract addresses not yet indexed will automatically start the indexing process for that NFT collection 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - token_id (String.t): The id of the token
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :offset (integer()): offset
    - :limit (integer()): limit
    - :cursor (String.t): The cursor returned in the last response (for getting the next page) 
  ## Returns

  {:ok, Moralis.Model.NftOwnerCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_id_owners(Tesla.Env.client, String.t, String.t, keyword()) :: {:ok, Moralis.Model.NftOwnerCollection.t} | {:error, Tesla.Env.t}
  def get_token_id_owners(connection, address, token_id, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"offset" => :query,
      :"limit" => :query,
      :"cursor" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/#{token_id}/owners")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftOwnerCollection{}}
    ])
  end

  @doc """
  Gets token metadata
  Returns metadata (name, symbol, decimals, logo) for a given token contract address.

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - addresses ([String.t]): The addresses to get metadata for
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :subdomain (String.t): The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
    - :provider_url (String.t): web3 provider url to user when using local dev chain
  ## Returns

  {:ok, [%Erc20Metadata{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_metadata(Tesla.Env.client, list(String.t), keyword()) :: {:ok, list(Moralis.Model.Erc20Metadata.t)} | {:error, Tesla.Env.t}
  def get_token_metadata(connection, addresses, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"subdomain" => :query,
      :"providerUrl" => :query
    }
    %{}
    |> method(:get)
    |> url("/erc20/metadata")
    |> add_param(:query, :"addresses", addresses)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, [%Moralis.Model.Erc20Metadata{}]}
    ])
  end

  @doc """
  Gets token metadata
  Returns metadata (name, symbol, decimals, logo) for a given token contract address.

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - symbols ([String.t]): The symbols to get metadata for
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :subdomain (String.t): The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
  ## Returns

  {:ok, [%Erc20Metadata{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_metadata_by_symbol(Tesla.Env.client, list(String.t), keyword()) :: {:ok, list(Moralis.Model.Erc20Metadata.t)} | {:error, Tesla.Env.t}
  def get_token_metadata_by_symbol(connection, symbols, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"subdomain" => :query
    }
    %{}
    |> method(:get)
    |> url("/erc20/metadata/symbols")
    |> add_param(:query, :"symbols", symbols)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, [%Moralis.Model.Erc20Metadata{}]}
    ])
  end

  @doc """
  Gets token price
  Returns the price nominated in the native token and usd for a given token contract address.

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): The address of the token contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :provider_url (String.t): web3 provider url to user when using local dev chain
    - :exchange (String.t): The factory name or address of the token exchange
    - :to_block (integer()): to_block
  ## Returns

  {:ok, Moralis.Model.Erc20Price.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_price(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.Erc20Price.t} | {:error, Tesla.Env.t}
  def get_token_price(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"providerUrl" => :query,
      :"exchange" => :query,
      :"to_block" => :query
    }
    %{}
    |> method(:get)
    |> url("/erc20/#{address}/price")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.Erc20Price{}}
    ])
  end

  @doc """
  Gets NFT transfers of a given contract
  Gets the transfers of the tokens matching the given parameters

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - token_id (String.t): The id of the token
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :offset (integer()): offset
    - :limit (integer()): limit
    - :order (String.t): The field(s) to order on and if it should be ordered in ascending or descending order. Specified by: fieldName1.order,fieldName2.order. Example 1: \"block_number\", \"block_number.ASC\", \"block_number.DESC\", Example 2: \"block_number and contract_type\", \"block_number.ASC,contract_type.DESC\"
    - :cursor (String.t): The cursor returned in the last response (for getting the next page) 
  ## Returns

  {:ok, Moralis.Model.NftTransferCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_wallet_token_id_transfers(Tesla.Env.client, String.t, String.t, keyword()) :: {:ok, Moralis.Model.NftTransferCollection.t} | {:error, Tesla.Env.t}
  def get_wallet_token_id_transfers(connection, address, token_id, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"offset" => :query,
      :"limit" => :query,
      :"order" => :query,
      :"cursor" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/#{token_id}/transfers")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftTransferCollection{}}
    ])
  end

  @doc """
  resync the metadata for a given token_id
  ReSync the metadata for an NFT * The metadata(default) flag will request a the NFT's metadata from the already existing token_uri * The uri flag will fetch the latest token_uri from the given NFT address. In sync mode the metadata will also be fetched * The sync mode will make the endpoint synchronous so it will wait for the task to be completed before responding * The async mode(default) will make the endpoint asynchronous so we will wait for the task to be completed before responding 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - token_id (String.t): The id of the token
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :flag (String.t): The type of resync to operate
    - :mode (String.t): To define the behaviour of the endpoint
  ## Returns

  {:ok, Moralis.Model.MetadataResync.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec re_sync_metadata(Tesla.Env.client, String.t, String.t, keyword()) :: {:ok, Moralis.Model.MetadataResync.t} | {:error, Tesla.Env.t}
  def re_sync_metadata(connection, address, token_id, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"flag" => :query,
      :"mode" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/#{address}/#{token_id}/metadata/resync")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.MetadataResync{}},
      { 202, %Moralis.Model.MetadataResync{}},
      { 404, %Moralis.Model.MetadataResync{}}
    ])
  end

  @doc """
  Retrieves the NFT data based on a metadata search
  Gets NFTs that match a given metadata search.

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - q (String.t): The search string
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :filter (String.t): What fields the search should match on. To look into the entire metadata set the value to 'global'. To have a better response time you can look into a specific field like name
    - :from_block (integer()): The minimum block number from where to start the search * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_block (integer()): The maximum block number from where to end the search * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :from_date (String.t): The date from where to start the search (any format that is accepted by momentjs) * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_date (String.t): Get search results up until this date (any format that is accepted by momentjs) * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :offset (integer()): offset
    - :limit (integer()): limit
  ## Returns

  {:ok, Moralis.Model.NftMetadataCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec search_nfts(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.NftMetadataCollection.t} | {:error, Tesla.Env.t}
  def search_nfts(connection, q, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"filter" => :query,
      :"from_block" => :query,
      :"to_block" => :query,
      :"from_date" => :query,
      :"to_date" => :query,
      :"offset" => :query,
      :"limit" => :query
    }
    %{}
    |> method(:get)
    |> url("/nft/search")
    |> add_param(:query, :"q", q)
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftMetadataCollection{}}
    ])
  end

  @doc """
  Sync a Contract for NFT Index
  Sync a Contract for NFT Index 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): Address of the contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
  ## Returns

  {:ok, nil} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec sync_nft_contract(Tesla.Env.client, String.t, keyword()) :: {:ok, nil} | {:error, Tesla.Env.t}
  def sync_nft_contract(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query
    }
    %{}
    |> method(:put)
    |> url("/nft/#{address}/sync")
    |> add_optional_params(optional_params, opts)
    |> ensure_body()
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 201, false}
    ])
  end
end
