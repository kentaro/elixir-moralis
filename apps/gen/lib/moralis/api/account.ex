# NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
# https://openapi-generator.tech
# Do not edit the class manually.

defmodule Moralis.Api.Account do
  @moduledoc """
  API calls for all endpoints tagged `Account`.
  """

  alias Moralis.Connection
  import Moralis.RequestBuilder


  @doc """
  Gets native balance for a specific address.
  Gets native balance for a specific address

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): The address for which the native balance will be checked
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :provider_url (String.t): web3 provider url to user when using local dev chain
    - :to_block (float()): The block number on which the balances should be checked
  ## Returns

  {:ok, Moralis.Model.NativeBalance.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_native_balance(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.NativeBalance.t} | {:error, Tesla.Env.t}
  def get_native_balance(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"providerUrl" => :query,
      :"to_block" => :query
    }
    %{}
    |> method(:get)
    |> url("/#{address}/balance")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NativeBalance{}}
    ])
  end

  @doc """
  Gets NFT transfers to and from a given address
  Gets the transfers of the tokens matching the given parameters

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): The sender or recepient of the transfer
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :direction (String.t): The transfer direction
    - :offset (integer()): offset
    - :limit (integer()): limit
    - :cursor (String.t): The cursor returned in the last response (for getting the next page) 
  ## Returns

  {:ok, Moralis.Model.NftTransferCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_nft_transfers(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.NftTransferCollection.t} | {:error, Tesla.Env.t}
  def get_nft_transfers(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"direction" => :query,
      :"offset" => :query,
      :"limit" => :query,
      :"cursor" => :query
    }
    %{}
    |> method(:get)
    |> url("/#{address}/nft/transfers")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftTransferCollection{}}
    ])
  end

  @doc """
  Gets the NFTs owned by a given address
  Gets NFTs owned by the given address * The response will include status [SYNCED/SYNCING] based on the contracts being indexed. * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): The owner of a given token
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :offset (integer()): offset
    - :limit (integer()): limit
    - :token_addresses ([String.t]): The addresses to get balances for (Optional)
    - :cursor (String.t): The cursor returned in the last response (for getting the next page) 
  ## Returns

  {:ok, Moralis.Model.NftOwnerCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_nfts(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.NftOwnerCollection.t} | {:error, Tesla.Env.t}
  def get_nfts(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"offset" => :query,
      :"limit" => :query,
      :"token_addresses" => :query,
      :"cursor" => :query
    }
    %{}
    |> method(:get)
    |> url("/#{address}/nft")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftOwnerCollection{}}
    ])
  end

  @doc """
  Gets the NFTs owned by a given address
  Gets NFTs owned by the given address * Use the token_address param to get results for a specific contract only * Note results will include all indexed NFTs * Any request which includes the token_address param will start the indexing process for that NFT collection the very first time it is requested 

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): The owner of a given token
  - token_address (String.t): Address of the contract
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :format (String.t): The format of the token id
    - :offset (integer()): offset
    - :limit (integer()): limit
  ## Returns

  {:ok, Moralis.Model.NftOwnerCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_nfts_for_contract(Tesla.Env.client, String.t, String.t, keyword()) :: {:ok, Moralis.Model.NftOwnerCollection.t} | {:error, Tesla.Env.t}
  def get_nfts_for_contract(connection, address, token_address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"format" => :query,
      :"offset" => :query,
      :"limit" => :query
    }
    %{}
    |> method(:get)
    |> url("/#{address}/nft/#{token_address}")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.NftOwnerCollection{}}
    ])
  end

  @doc """
  Gets token balances for a specific address.
  Gets token balances for a specific address

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): The address for which token balances will be checked
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :subdomain (String.t): The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
    - :to_block (float()): The block number on which the balances should be checked
    - :token_addresses ([String.t]): The addresses to get balances for (Optional)
  ## Returns

  {:ok, [%Erc20TokenBalance{}, ...]} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_balances(Tesla.Env.client, String.t, keyword()) :: {:ok, list(Moralis.Model.Erc20TokenBalance.t)} | {:error, Tesla.Env.t}
  def get_token_balances(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"subdomain" => :query,
      :"to_block" => :query,
      :"token_addresses" => :query
    }
    %{}
    |> method(:get)
    |> url("/#{address}/erc20")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, [%Moralis.Model.Erc20TokenBalance{}]}
    ])
  end

  @doc """
  Gets erc 20 token transactions
  Gets ERC20 token transactions in descending order based on block number

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): address
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :subdomain (String.t): The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
    - :from_block (integer()): The minimum block number from where to get the transactions * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_block (integer()): The maximum block number from where to get the transactions. * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :from_date (String.t): The date from where to get the transactions (any format that is accepted by momentjs) * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_date (String.t): Get the transactions to this date (any format that is accepted by momentjs) * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :offset (integer()): offset
    - :limit (integer()): limit
  ## Returns

  {:ok, Moralis.Model.Erc20TransactionCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_token_transfers(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.Erc20TransactionCollection.t} | {:error, Tesla.Env.t}
  def get_token_transfers(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"subdomain" => :query,
      :"from_block" => :query,
      :"to_block" => :query,
      :"from_date" => :query,
      :"to_date" => :query,
      :"offset" => :query,
      :"limit" => :query
    }
    %{}
    |> method(:get)
    |> url("/#{address}/erc20/transfers")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.Erc20TransactionCollection{}}
    ])
  end

  @doc """
  Gets native transactions
  Gets native transactions in descending order based on block number

  ## Parameters

  - connection (Moralis.Connection): Connection to server
  - address (String.t): address
  - opts (KeywordList): [optional] Optional parameters
    - :chain (Moralis.Model.ChainList.t): The chain to query
    - :subdomain (String.t): The subdomain of the moralis server to use (Only use when selecting local devchain as chain)
    - :from_block (integer()): The minimum block number from where to get the transactions * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_block (integer()): The maximum block number from where to get the transactions. * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :from_date (String.t): The date from where to get the transactions (any format that is accepted by momentjs) * Provide the param 'from_block' or 'from_date' * If 'from_date' and 'from_block' are provided, 'from_block' will be used. 
    - :to_date (String.t): Get the transactions to this date (any format that is accepted by momentjs) * Provide the param 'to_block' or 'to_date' * If 'to_date' and 'to_block' are provided, 'to_block' will be used. 
    - :offset (integer()): offset
    - :limit (integer()): limit
  ## Returns

  {:ok, Moralis.Model.TransactionCollection.t} on success
  {:error, Tesla.Env.t} on failure
  """
  @spec get_transactions(Tesla.Env.client, String.t, keyword()) :: {:ok, Moralis.Model.TransactionCollection.t} | {:error, Tesla.Env.t}
  def get_transactions(connection, address, opts \\ []) do
    optional_params = %{
      :"chain" => :query,
      :"subdomain" => :query,
      :"from_block" => :query,
      :"to_block" => :query,
      :"from_date" => :query,
      :"to_date" => :query,
      :"offset" => :query,
      :"limit" => :query
    }
    %{}
    |> method(:get)
    |> url("/#{address}")
    |> add_optional_params(optional_params, opts)
    |> Enum.into([])
    |> (&Connection.request(connection, &1)).()
    |> evaluate_response([
      { 200, %Moralis.Model.TransactionCollection{}}
    ])
  end
end
